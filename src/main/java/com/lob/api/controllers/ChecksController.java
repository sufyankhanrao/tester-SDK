/*
 * LobAPI20200211SpecificationLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.lob.api.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.lob.api.ApiHelper;
import com.lob.api.AuthManager;
import com.lob.api.Configuration;
import com.lob.api.DateTimeHelper;
import com.lob.api.exceptions.ApiException;
import com.lob.api.exceptions.ErrorErrorException;
import com.lob.api.http.Headers;
import com.lob.api.http.client.HttpCallback;
import com.lob.api.http.client.HttpClient;
import com.lob.api.http.client.HttpContext;
import com.lob.api.http.request.HttpRequest;
import com.lob.api.http.response.HttpResponse;
import com.lob.api.http.response.HttpStringResponse;
import com.lob.api.models.AllChecks;
import com.lob.api.models.Check;
import com.lob.api.models.CheckDeletion;
import com.lob.api.models.MailTypeEnum;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.AbstractMap.SimpleEntry;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * This class lists all the endpoints of the groups.
 */
public final class ChecksController extends BaseController {

    /**
     * Initializes the controller.
     * @param config    Configurations added in client.
     * @param httpClient    Send HTTP requests and read the responses.
     * @param authManagers    Apply authorization to requests.
     */
    public ChecksController(Configuration config, HttpClient httpClient,
            Map<String, AuthManager> authManagers) {
        super(config, httpClient, authManagers);
    }

    /**
     * Initializes the controller with HTTPCallback.
     * @param config    Configurations added in client.
     * @param httpClient    Send HTTP requests and read the responses.
     * @param authManagers    Apply authorization to requests.
     * @param httpCallback    Callback to be called before and after the HTTP call.
     */
    public ChecksController(Configuration config, HttpClient httpClient,
            Map<String, AuthManager> authManagers, HttpCallback httpCallback) {
        super(config, httpClient, authManagers, httpCallback);
    }

    /**
     * Retrieves the details of an existing check. You need only supply the unique check identifier
     * that was returned upon check creation.
     * @param  chkId  Required parameter: id of the check
     * @return    Returns the Check response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Check getCheck(
            final String chkId) throws ApiException, IOException {
        HttpRequest request = buildGetCheckRequest(chkId);
        authManagers.get("global").apply(request);

        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        return handleGetCheckResponse(context);
    }

    /**
     * Retrieves the details of an existing check. You need only supply the unique check identifier
     * that was returned upon check creation.
     * @param  chkId  Required parameter: id of the check
     * @return    Returns the Check response from the API call
     */
    public CompletableFuture<Check> getCheckAsync(
            final String chkId) {
        return makeHttpCallAsync(() -> buildGetCheckRequest(chkId),
            req -> authManagers.get("global").applyAsync(req)
                .thenCompose(request -> getClientInstance()
                        .executeAsync(request, false)),
            context -> handleGetCheckResponse(context));
    }

    /**
     * Builds the HttpRequest object for getCheck.
     */
    private HttpRequest buildGetCheckRequest(
            final String chkId) {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/checks/{chk_id}");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("chk_id",
                new SimpleEntry<Object, Boolean>(chkId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().get(queryBuilder, headers, null, null);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for getCheck.
     * @return An object of type Check
     */
    private Check handleGetCheckResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorErrorException("Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse) response).getBody();
        Check result = ApiHelper.deserialize(responseBody,
                Check.class);

        return result;
    }

    /**
     * Completely removes a check from production. This can only be done if the check has a
     * `send_date` and the `send_date` has not yet passed. If the check is successfully canceled,
     * you will not be charged for it. Read more on [cancellation
     * windows](#section/Cancellation-Windows) and [scheduling](#section/Scheduled-Mailings).
     * Scheduling and cancellation is a premium feature. Upgrade to the appropriate [Print & Mail
     * Edition](https://dashboard.lob.com/#/settings/editions) to gain access.
     * @param  chkId  Required parameter: id of the check
     * @return    Returns the CheckDeletion response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public CheckDeletion cancelCheck(
            final String chkId) throws ApiException, IOException {
        HttpRequest request = buildCancelCheckRequest(chkId);
        authManagers.get("global").apply(request);

        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        return handleCancelCheckResponse(context);
    }

    /**
     * Completely removes a check from production. This can only be done if the check has a
     * `send_date` and the `send_date` has not yet passed. If the check is successfully canceled,
     * you will not be charged for it. Read more on [cancellation
     * windows](#section/Cancellation-Windows) and [scheduling](#section/Scheduled-Mailings).
     * Scheduling and cancellation is a premium feature. Upgrade to the appropriate [Print & Mail
     * Edition](https://dashboard.lob.com/#/settings/editions) to gain access.
     * @param  chkId  Required parameter: id of the check
     * @return    Returns the CheckDeletion response from the API call
     */
    public CompletableFuture<CheckDeletion> cancelCheckAsync(
            final String chkId) {
        return makeHttpCallAsync(() -> buildCancelCheckRequest(chkId),
            req -> authManagers.get("global").applyAsync(req)
                .thenCompose(request -> getClientInstance()
                        .executeAsync(request, false)),
            context -> handleCancelCheckResponse(context));
    }

    /**
     * Builds the HttpRequest object for cancelCheck.
     */
    private HttpRequest buildCancelCheckRequest(
            final String chkId) {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/checks/{chk_id}");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("chk_id",
                new SimpleEntry<Object, Boolean>(chkId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().delete(queryBuilder, headers, null, null);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for cancelCheck.
     * @return An object of type CheckDeletion
     */
    private CheckDeletion handleCancelCheckResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorErrorException("Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse) response).getBody();
        CheckDeletion result = ApiHelper.deserialize(responseBody,
                CheckDeletion.class);

        return result;
    }

    /**
     * Returns a list of your checks. The checks are returned sorted by creation date, with the most
     * recently created checks appearing first.
     * @param  limit  Optional parameter: How many results to return.
     * @param  beforeOrAfter  Optional parameter: before and after are both optional but only one of
     *         them can be in the query at a time.
     * @param  include  Optional parameter: Request that the response include the total count by
     *         specifying `include[]=total_count`.
     * @param  dateCreated  Optional parameter: Filter by ISO-8601 date or datetime, e.g. `{ gt:
     *         '2012-01-01', lt: '2012-01-31T12:34:56Z' }` where `gt` is &gt;, `lt` is &lt;, `gte` is ≥,
     *         and `lte` is ≤.
     * @param  metadata  Optional parameter: Filter by metadata key-value pair, e.g.
     *         `metadata[customer_id]=987654`.
     * @param  scheduled  Optional parameter: * `true` - only return orders (past or future) where
     *         `send_date` is greater than `date_created` * `false` - only return orders where
     *         `send_date` is equal to `date_created`
     * @param  sendDate  Optional parameter: Filter by ISO-8601 date or datetime, e.g. `{ gt:
     *         '2012-01-01', lt: '2012-01-31T12:34:56Z' }` where `gt` is &gt;, `lt` is &lt;, `gte` is ≥,
     *         and `lte` is ≤.
     * @param  mailType  Optional parameter: A string designating the mail postage type: *
     *         `usps_first_class` - (default) * `usps_standard` - a [cheaper
     *         option](https://lob.com/pricing/print-mail#compare) which is less predictable and
     *         takes longer to deliver. `usps_standard` cannot be used with `4x6` postcards or for
     *         any postcards sent outside of the United States.
     * @param  sortBy  Optional parameter: Sorts postcards by ascending or descending dates.
     * @return    Returns the AllChecks response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public AllChecks listChecks(
            final Integer limit,
            final Object beforeOrAfter,
            final Object include,
            final LocalDateTime dateCreated,
            final Integer metadata,
            final Boolean scheduled,
            final Object sendDate,
            final MailTypeEnum mailType,
            final Object sortBy) throws ApiException, IOException {
        HttpRequest request = buildListChecksRequest(limit, beforeOrAfter, include, dateCreated,
                metadata, scheduled, sendDate, mailType, sortBy);
        authManagers.get("global").apply(request);

        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        return handleListChecksResponse(context);
    }

    /**
     * Returns a list of your checks. The checks are returned sorted by creation date, with the most
     * recently created checks appearing first.
     * @param  limit  Optional parameter: How many results to return.
     * @param  beforeOrAfter  Optional parameter: before and after are both optional but only one of
     *         them can be in the query at a time.
     * @param  include  Optional parameter: Request that the response include the total count by
     *         specifying `include[]=total_count`.
     * @param  dateCreated  Optional parameter: Filter by ISO-8601 date or datetime, e.g. `{ gt:
     *         '2012-01-01', lt: '2012-01-31T12:34:56Z' }` where `gt` is &gt;, `lt` is &lt;, `gte` is ≥,
     *         and `lte` is ≤.
     * @param  metadata  Optional parameter: Filter by metadata key-value pair, e.g.
     *         `metadata[customer_id]=987654`.
     * @param  scheduled  Optional parameter: * `true` - only return orders (past or future) where
     *         `send_date` is greater than `date_created` * `false` - only return orders where
     *         `send_date` is equal to `date_created`
     * @param  sendDate  Optional parameter: Filter by ISO-8601 date or datetime, e.g. `{ gt:
     *         '2012-01-01', lt: '2012-01-31T12:34:56Z' }` where `gt` is &gt;, `lt` is &lt;, `gte` is ≥,
     *         and `lte` is ≤.
     * @param  mailType  Optional parameter: A string designating the mail postage type: *
     *         `usps_first_class` - (default) * `usps_standard` - a [cheaper
     *         option](https://lob.com/pricing/print-mail#compare) which is less predictable and
     *         takes longer to deliver. `usps_standard` cannot be used with `4x6` postcards or for
     *         any postcards sent outside of the United States.
     * @param  sortBy  Optional parameter: Sorts postcards by ascending or descending dates.
     * @return    Returns the AllChecks response from the API call
     */
    public CompletableFuture<AllChecks> listChecksAsync(
            final Integer limit,
            final Object beforeOrAfter,
            final Object include,
            final LocalDateTime dateCreated,
            final Integer metadata,
            final Boolean scheduled,
            final Object sendDate,
            final MailTypeEnum mailType,
            final Object sortBy) {
        return makeHttpCallAsync(() -> buildListChecksRequest(limit, beforeOrAfter, include,
                dateCreated, metadata, scheduled, sendDate, mailType, sortBy),
            req -> authManagers.get("global").applyAsync(req)
                .thenCompose(request -> getClientInstance()
                        .executeAsync(request, false)),
            context -> handleListChecksResponse(context));
    }

    /**
     * Builds the HttpRequest object for listChecks.
     */
    private HttpRequest buildListChecksRequest(
            final Integer limit,
            final Object beforeOrAfter,
            final Object include,
            final LocalDateTime dateCreated,
            final Integer metadata,
            final Boolean scheduled,
            final Object sendDate,
            final MailTypeEnum mailType,
            final Object sortBy) {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/checks");

        //load all query parameters
        Map<String, Object> queryParameters = new HashMap<>();
        queryParameters.put("limit",
                (limit != null) ? limit : 10);
        queryParameters.put("before-or-after", beforeOrAfter);
        queryParameters.put("include", include);
        queryParameters.put("date_created", DateTimeHelper.toRfc8601DateTime(dateCreated));
        queryParameters.put("metadata",
                (metadata != null) ? metadata : 0);
        queryParameters.put("scheduled", scheduled);
        queryParameters.put("send_date", sendDate);
        queryParameters.put("mail_type",
                (mailType != null) ? mailType.value() : "usps_first_class");
        queryParameters.put("sort_by", sortBy);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().get(queryBuilder, headers, queryParameters,
                null);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for listChecks.
     * @return An object of type AllChecks
     */
    private AllChecks handleListChecksResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorErrorException("Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse) response).getBody();
        AllChecks result = ApiHelper.deserialize(responseBody,
                AllChecks.class);

        return result;
    }

    /**
     * Creates a new check with the provided properties.
     * @param  body  Required parameter: Example:
     * @param  idempotencyKeyHeader  Optional parameter: A string of no longer than 256 characters
     *         that uniquely identifies this resource. For more help integrating idempotency keys,
     *         refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @param  idempotencyKeyParam  Optional parameter: A string of no longer than 256 characters
     *         that uniquely identifies this resource. For more help integrating idempotency keys,
     *         refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @return    Returns the Check response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Check createCheck(
            final Object body,
            final String idempotencyKeyHeader,
            final String idempotencyKeyParam) throws ApiException, IOException {
        HttpRequest request = buildCreateCheckRequest(body, idempotencyKeyHeader,
                idempotencyKeyParam);
        authManagers.get("global").apply(request);

        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        return handleCreateCheckResponse(context);
    }

    /**
     * Creates a new check with the provided properties.
     * @param  body  Required parameter: Example:
     * @param  idempotencyKeyHeader  Optional parameter: A string of no longer than 256 characters
     *         that uniquely identifies this resource. For more help integrating idempotency keys,
     *         refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @param  idempotencyKeyParam  Optional parameter: A string of no longer than 256 characters
     *         that uniquely identifies this resource. For more help integrating idempotency keys,
     *         refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @return    Returns the Check response from the API call
     */
    public CompletableFuture<Check> createCheckAsync(
            final Object body,
            final String idempotencyKeyHeader,
            final String idempotencyKeyParam) {
        return makeHttpCallAsync(() -> buildCreateCheckRequest(body, idempotencyKeyHeader,
                idempotencyKeyParam),
            req -> authManagers.get("global").applyAsync(req)
                .thenCompose(request -> getClientInstance()
                        .executeAsync(request, false)),
            context -> handleCreateCheckResponse(context));
    }

    /**
     * Builds the HttpRequest object for createCheck.
     */
    private HttpRequest buildCreateCheckRequest(
            final Object body,
            final String idempotencyKeyHeader,
            final String idempotencyKeyParam) throws JsonProcessingException {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/checks");

        //load all query parameters
        Map<String, Object> queryParameters = new HashMap<>();
        queryParameters.put("idempotency_key_param", idempotencyKeyParam);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("Idempotency-Key-Header", idempotencyKeyHeader);
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");
        headers.add("content-type", "application/json");

        //prepare and invoke the API call request to fetch the response
        String bodyJson = ApiHelper.serialize(body);
        HttpRequest request = getClientInstance().postBody(queryBuilder, headers, queryParameters,
                bodyJson);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for createCheck.
     * @return An object of type Check
     */
    private Check handleCreateCheckResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorErrorException("Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse) response).getBody();
        Check result = ApiHelper.deserialize(responseBody,
                Check.class);

        return result;
    }

}