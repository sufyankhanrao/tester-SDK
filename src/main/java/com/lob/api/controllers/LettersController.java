/*
 * LobAPI20200211SpecificationLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.lob.api.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.lob.api.ApiHelper;
import com.lob.api.AuthManager;
import com.lob.api.Configuration;
import com.lob.api.DateTimeHelper;
import com.lob.api.exceptions.ApiException;
import com.lob.api.exceptions.ErrorErrorException;
import com.lob.api.http.Headers;
import com.lob.api.http.client.HttpCallback;
import com.lob.api.http.client.HttpClient;
import com.lob.api.http.client.HttpContext;
import com.lob.api.http.request.HttpRequest;
import com.lob.api.http.response.HttpResponse;
import com.lob.api.http.response.HttpStringResponse;
import com.lob.api.models.AllLetters;
import com.lob.api.models.DynamicResponse;
import com.lob.api.models.LetterDeletion;
import com.lob.api.models.LetterEditable;
import com.lob.api.models.MailTypeEnum;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.AbstractMap.SimpleEntry;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * This class lists all the endpoints of the groups.
 */
public final class LettersController extends BaseController {

    /**
     * Initializes the controller.
     * @param config    Configurations added in client.
     * @param httpClient    Send HTTP requests and read the responses.
     * @param authManagers    Apply authorization to requests.
     */
    public LettersController(Configuration config, HttpClient httpClient,
            Map<String, AuthManager> authManagers) {
        super(config, httpClient, authManagers);
    }

    /**
     * Initializes the controller with HTTPCallback.
     * @param config    Configurations added in client.
     * @param httpClient    Send HTTP requests and read the responses.
     * @param authManagers    Apply authorization to requests.
     * @param httpCallback    Callback to be called before and after the HTTP call.
     */
    public LettersController(Configuration config, HttpClient httpClient,
            Map<String, AuthManager> authManagers, HttpCallback httpCallback) {
        super(config, httpClient, authManagers, httpCallback);
    }

    /**
     * Retrieves the details of an existing letter. You need only supply the unique letter
     * identifier that was returned upon letter creation.
     * @param  ltrId  Required parameter: id of the letter
     * @return    Returns the DynamicResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public DynamicResponse getLetter(
            final String ltrId) throws ApiException, IOException {
        HttpRequest request = buildGetLetterRequest(ltrId);
        authManagers.get("global").apply(request);

        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        return handleGetLetterResponse(context);
    }

    /**
     * Retrieves the details of an existing letter. You need only supply the unique letter
     * identifier that was returned upon letter creation.
     * @param  ltrId  Required parameter: id of the letter
     * @return    Returns the DynamicResponse response from the API call
     */
    public CompletableFuture<DynamicResponse> getLetterAsync(
            final String ltrId) {
        return makeHttpCallAsync(() -> buildGetLetterRequest(ltrId),
            req -> authManagers.get("global").applyAsync(req)
                .thenCompose(request -> getClientInstance()
                        .executeAsync(request, false)),
            context -> handleGetLetterResponse(context));
    }

    /**
     * Builds the HttpRequest object for getLetter.
     */
    private HttpRequest buildGetLetterRequest(
            final String ltrId) {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/letters/{ltr_id}");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("ltr_id",
                new SimpleEntry<Object, Boolean>(ltrId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().get(queryBuilder, headers, null, null);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for getLetter.
     * @return An object of type DynamicResponse
     */
    private DynamicResponse handleGetLetterResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorErrorException("Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        DynamicResponse result = new DynamicResponse(response);

        return result;
    }

    /**
     * Completely removes a letter from production. This can only be done if the letter has a
     * `send_date` and the `send_date` has not yet passed. If the letter is successfully canceled,
     * you will not be charged for it. Read more on [cancellation
     * windows](#section/Cancellation-Windows) and [scheduling](#section/Scheduled-Mailings).
     * Scheduling and cancellation is a premium feature. Upgrade to the appropriate [Print & Mail
     * Edition](https://dashboard.lob.com/#/settings/editions) to gain access.
     * @param  ltrId  Required parameter: id of the letter
     * @return    Returns the LetterDeletion response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public LetterDeletion cancelLetter(
            final String ltrId) throws ApiException, IOException {
        HttpRequest request = buildCancelLetterRequest(ltrId);
        authManagers.get("global").apply(request);

        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        return handleCancelLetterResponse(context);
    }

    /**
     * Completely removes a letter from production. This can only be done if the letter has a
     * `send_date` and the `send_date` has not yet passed. If the letter is successfully canceled,
     * you will not be charged for it. Read more on [cancellation
     * windows](#section/Cancellation-Windows) and [scheduling](#section/Scheduled-Mailings).
     * Scheduling and cancellation is a premium feature. Upgrade to the appropriate [Print & Mail
     * Edition](https://dashboard.lob.com/#/settings/editions) to gain access.
     * @param  ltrId  Required parameter: id of the letter
     * @return    Returns the LetterDeletion response from the API call
     */
    public CompletableFuture<LetterDeletion> cancelLetterAsync(
            final String ltrId) {
        return makeHttpCallAsync(() -> buildCancelLetterRequest(ltrId),
            req -> authManagers.get("global").applyAsync(req)
                .thenCompose(request -> getClientInstance()
                        .executeAsync(request, false)),
            context -> handleCancelLetterResponse(context));
    }

    /**
     * Builds the HttpRequest object for cancelLetter.
     */
    private HttpRequest buildCancelLetterRequest(
            final String ltrId) {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/letters/{ltr_id}");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("ltr_id",
                new SimpleEntry<Object, Boolean>(ltrId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().delete(queryBuilder, headers, null, null);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for cancelLetter.
     * @return An object of type LetterDeletion
     */
    private LetterDeletion handleCancelLetterResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorErrorException("Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse) response).getBody();
        LetterDeletion result = ApiHelper.deserialize(responseBody,
                LetterDeletion.class);

        return result;
    }

    /**
     * Returns a list of your letters. The letters are returned sorted by creation date, with the
     * most recently created letters appearing first.
     * @param  limit  Optional parameter: How many results to return.
     * @param  beforeOrAfter  Optional parameter: before and after are both optional but only one of
     *         them can be in the query at a time.
     * @param  include  Optional parameter: Request that the response include the total count by
     *         specifying `include[]=total_count`.
     * @param  dateCreated  Optional parameter: Filter by ISO-8601 date or datetime, e.g. `{ gt:
     *         '2012-01-01', lt: '2012-01-31T12:34:56Z' }` where `gt` is &gt;, `lt` is &lt;, `gte` is ≥,
     *         and `lte` is ≤.
     * @param  metadata  Optional parameter: Filter by metadata key-value pair, e.g.
     *         `metadata[customer_id]=987654`.
     * @param  color  Optional parameter: Set to `true` to return only color letters. Set to `false`
     *         to return only black & white letters.
     * @param  scheduled  Optional parameter: * `true` - only return orders (past or future) where
     *         `send_date` is greater than `date_created` * `false` - only return orders where
     *         `send_date` is equal to `date_created`
     * @param  sendDate  Optional parameter: Filter by ISO-8601 date or datetime, e.g. `{ gt:
     *         '2012-01-01', lt: '2012-01-31T12:34:56Z' }` where `gt` is &gt;, `lt` is &lt;, `gte` is ≥,
     *         and `lte` is ≤.
     * @param  mailType  Optional parameter: A string designating the mail postage type: *
     *         `usps_first_class` - (default) * `usps_standard` - a [cheaper
     *         option](https://lob.com/pricing/print-mail#compare) which is less predictable and
     *         takes longer to deliver. `usps_standard` cannot be used with `4x6` postcards or for
     *         any postcards sent outside of the United States.
     * @param  sortBy  Optional parameter: Sorts postcards by ascending or descending dates.
     * @return    Returns the AllLetters response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public AllLetters listLetters(
            final Integer limit,
            final Object beforeOrAfter,
            final Object include,
            final LocalDateTime dateCreated,
            final Integer metadata,
            final Boolean color,
            final Boolean scheduled,
            final Object sendDate,
            final MailTypeEnum mailType,
            final Object sortBy) throws ApiException, IOException {
        HttpRequest request = buildListLettersRequest(limit, beforeOrAfter, include, dateCreated,
                metadata, color, scheduled, sendDate, mailType, sortBy);
        authManagers.get("global").apply(request);

        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        return handleListLettersResponse(context);
    }

    /**
     * Returns a list of your letters. The letters are returned sorted by creation date, with the
     * most recently created letters appearing first.
     * @param  limit  Optional parameter: How many results to return.
     * @param  beforeOrAfter  Optional parameter: before and after are both optional but only one of
     *         them can be in the query at a time.
     * @param  include  Optional parameter: Request that the response include the total count by
     *         specifying `include[]=total_count`.
     * @param  dateCreated  Optional parameter: Filter by ISO-8601 date or datetime, e.g. `{ gt:
     *         '2012-01-01', lt: '2012-01-31T12:34:56Z' }` where `gt` is &gt;, `lt` is &lt;, `gte` is ≥,
     *         and `lte` is ≤.
     * @param  metadata  Optional parameter: Filter by metadata key-value pair, e.g.
     *         `metadata[customer_id]=987654`.
     * @param  color  Optional parameter: Set to `true` to return only color letters. Set to `false`
     *         to return only black & white letters.
     * @param  scheduled  Optional parameter: * `true` - only return orders (past or future) where
     *         `send_date` is greater than `date_created` * `false` - only return orders where
     *         `send_date` is equal to `date_created`
     * @param  sendDate  Optional parameter: Filter by ISO-8601 date or datetime, e.g. `{ gt:
     *         '2012-01-01', lt: '2012-01-31T12:34:56Z' }` where `gt` is &gt;, `lt` is &lt;, `gte` is ≥,
     *         and `lte` is ≤.
     * @param  mailType  Optional parameter: A string designating the mail postage type: *
     *         `usps_first_class` - (default) * `usps_standard` - a [cheaper
     *         option](https://lob.com/pricing/print-mail#compare) which is less predictable and
     *         takes longer to deliver. `usps_standard` cannot be used with `4x6` postcards or for
     *         any postcards sent outside of the United States.
     * @param  sortBy  Optional parameter: Sorts postcards by ascending or descending dates.
     * @return    Returns the AllLetters response from the API call
     */
    public CompletableFuture<AllLetters> listLettersAsync(
            final Integer limit,
            final Object beforeOrAfter,
            final Object include,
            final LocalDateTime dateCreated,
            final Integer metadata,
            final Boolean color,
            final Boolean scheduled,
            final Object sendDate,
            final MailTypeEnum mailType,
            final Object sortBy) {
        return makeHttpCallAsync(() -> buildListLettersRequest(limit, beforeOrAfter, include,
                dateCreated, metadata, color, scheduled, sendDate, mailType, sortBy),
            req -> authManagers.get("global").applyAsync(req)
                .thenCompose(request -> getClientInstance()
                        .executeAsync(request, false)),
            context -> handleListLettersResponse(context));
    }

    /**
     * Builds the HttpRequest object for listLetters.
     */
    private HttpRequest buildListLettersRequest(
            final Integer limit,
            final Object beforeOrAfter,
            final Object include,
            final LocalDateTime dateCreated,
            final Integer metadata,
            final Boolean color,
            final Boolean scheduled,
            final Object sendDate,
            final MailTypeEnum mailType,
            final Object sortBy) {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/letters");

        //load all query parameters
        Map<String, Object> queryParameters = new HashMap<>();
        queryParameters.put("limit",
                (limit != null) ? limit : 10);
        queryParameters.put("before-or-after", beforeOrAfter);
        queryParameters.put("include", include);
        queryParameters.put("date_created", DateTimeHelper.toRfc8601DateTime(dateCreated));
        queryParameters.put("metadata",
                (metadata != null) ? metadata : 0);
        queryParameters.put("color", color);
        queryParameters.put("scheduled", scheduled);
        queryParameters.put("send_date", sendDate);
        queryParameters.put("mail_type",
                (mailType != null) ? mailType.value() : "usps_first_class");
        queryParameters.put("sort_by", sortBy);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().get(queryBuilder, headers, queryParameters,
                null);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for listLetters.
     * @return An object of type AllLetters
     */
    private AllLetters handleListLettersResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorErrorException("Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse) response).getBody();
        AllLetters result = ApiHelper.deserialize(responseBody,
                AllLetters.class);

        return result;
    }

    /**
     * Creates a new letter given information.
     * @param  body  Required parameter: Example:
     * @param  idempotencyKeyHeader  Optional parameter: A string of no longer than 256 characters
     *         that uniquely identifies this resource. For more help integrating idempotency keys,
     *         refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @param  idempotencyKeyParam  Optional parameter: A string of no longer than 256 characters
     *         that uniquely identifies this resource. For more help integrating idempotency keys,
     *         refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @return    Returns the DynamicResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public DynamicResponse createLetter(
            final LetterEditable body,
            final String idempotencyKeyHeader,
            final String idempotencyKeyParam) throws ApiException, IOException {
        HttpRequest request = buildCreateLetterRequest(body, idempotencyKeyHeader,
                idempotencyKeyParam);
        authManagers.get("global").apply(request);

        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        return handleCreateLetterResponse(context);
    }

    /**
     * Creates a new letter given information.
     * @param  body  Required parameter: Example:
     * @param  idempotencyKeyHeader  Optional parameter: A string of no longer than 256 characters
     *         that uniquely identifies this resource. For more help integrating idempotency keys,
     *         refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @param  idempotencyKeyParam  Optional parameter: A string of no longer than 256 characters
     *         that uniquely identifies this resource. For more help integrating idempotency keys,
     *         refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @return    Returns the DynamicResponse response from the API call
     */
    public CompletableFuture<DynamicResponse> createLetterAsync(
            final LetterEditable body,
            final String idempotencyKeyHeader,
            final String idempotencyKeyParam) {
        return makeHttpCallAsync(() -> buildCreateLetterRequest(body, idempotencyKeyHeader,
                idempotencyKeyParam),
            req -> authManagers.get("global").applyAsync(req)
                .thenCompose(request -> getClientInstance()
                        .executeAsync(request, false)),
            context -> handleCreateLetterResponse(context));
    }

    /**
     * Builds the HttpRequest object for createLetter.
     */
    private HttpRequest buildCreateLetterRequest(
            final LetterEditable body,
            final String idempotencyKeyHeader,
            final String idempotencyKeyParam) throws JsonProcessingException {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/letters");

        //load all query parameters
        Map<String, Object> queryParameters = new HashMap<>();
        queryParameters.put("idempotency_key_param", idempotencyKeyParam);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("Idempotency-Key-Header", idempotencyKeyHeader);
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");
        headers.add("content-type", "application/json");

        //prepare and invoke the API call request to fetch the response
        String bodyJson = ApiHelper.serialize(body);
        HttpRequest request = getClientInstance().postBody(queryBuilder, headers, queryParameters,
                bodyJson);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for createLetter.
     * @return An object of type DynamicResponse
     */
    private DynamicResponse handleCreateLetterResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorErrorException("Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        DynamicResponse result = new DynamicResponse(response);

        return result;
    }

}