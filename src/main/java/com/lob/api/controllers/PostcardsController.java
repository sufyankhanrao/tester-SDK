/*
 * LobAPI20200211SpecificationLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.lob.api.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.lob.api.ApiHelper;
import com.lob.api.AuthManager;
import com.lob.api.Configuration;
import com.lob.api.DateTimeHelper;
import com.lob.api.exceptions.ApiException;
import com.lob.api.exceptions.ErrorErrorException;
import com.lob.api.http.Headers;
import com.lob.api.http.client.HttpCallback;
import com.lob.api.http.client.HttpClient;
import com.lob.api.http.client.HttpContext;
import com.lob.api.http.request.HttpRequest;
import com.lob.api.http.response.HttpResponse;
import com.lob.api.http.response.HttpStringResponse;
import com.lob.api.models.AllPostcards;
import com.lob.api.models.MailTypeEnum;
import com.lob.api.models.Postcard;
import com.lob.api.models.PostcardDeletion;
import com.lob.api.models.PostcardEditable;
import com.lob.api.models.PostcardSizeEnum;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.AbstractMap.SimpleEntry;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * This class lists all the endpoints of the groups.
 */
public final class PostcardsController extends BaseController {

    /**
     * Initializes the controller.
     * @param config    Configurations added in client.
     * @param httpClient    Send HTTP requests and read the responses.
     * @param authManagers    Apply authorization to requests.
     */
    public PostcardsController(Configuration config, HttpClient httpClient,
            Map<String, AuthManager> authManagers) {
        super(config, httpClient, authManagers);
    }

    /**
     * Initializes the controller with HTTPCallback.
     * @param config    Configurations added in client.
     * @param httpClient    Send HTTP requests and read the responses.
     * @param authManagers    Apply authorization to requests.
     * @param httpCallback    Callback to be called before and after the HTTP call.
     */
    public PostcardsController(Configuration config, HttpClient httpClient,
            Map<String, AuthManager> authManagers, HttpCallback httpCallback) {
        super(config, httpClient, authManagers, httpCallback);
    }

    /**
     * Retrieves the details of an existing postcard. You need only supply the unique customer
     * identifier that was returned upon postcard creation.
     * @param  pscId  Required parameter: id of the postcard
     * @return    Returns the Postcard response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Postcard getPostcard(
            final String pscId) throws ApiException, IOException {
        HttpRequest request = buildGetPostcardRequest(pscId);
        authManagers.get("global").apply(request);

        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        return handleGetPostcardResponse(context);
    }

    /**
     * Retrieves the details of an existing postcard. You need only supply the unique customer
     * identifier that was returned upon postcard creation.
     * @param  pscId  Required parameter: id of the postcard
     * @return    Returns the Postcard response from the API call
     */
    public CompletableFuture<Postcard> getPostcardAsync(
            final String pscId) {
        return makeHttpCallAsync(() -> buildGetPostcardRequest(pscId),
            req -> authManagers.get("global").applyAsync(req)
                .thenCompose(request -> getClientInstance()
                        .executeAsync(request, false)),
            context -> handleGetPostcardResponse(context));
    }

    /**
     * Builds the HttpRequest object for getPostcard.
     */
    private HttpRequest buildGetPostcardRequest(
            final String pscId) {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/postcards/{psc_id}");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("psc_id",
                new SimpleEntry<Object, Boolean>(pscId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().get(queryBuilder, headers, null, null);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for getPostcard.
     * @return An object of type Postcard
     */
    private Postcard handleGetPostcardResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorErrorException("Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse) response).getBody();
        Postcard result = ApiHelper.deserialize(responseBody,
                Postcard.class);

        return result;
    }

    /**
     * Completely removes a postcard from production. This can only be done if the postcard has a
     * `send_date` and the `send_date` has not yet passed. If the postcard is successfully canceled,
     * you will not be charged for it. Read more on [cancellation
     * windows](#section/Cancellation-Windows) and [scheduling](#section/Scheduled-Mailings).
     * Scheduling and cancellation is a premium feature. Upgrade to the appropriate [Print & Mail
     * Edition](https://dashboard.lob.com/#/settings/editions) to gain access.
     * @param  pscId  Required parameter: id of the postcard
     * @return    Returns the PostcardDeletion response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public PostcardDeletion deletePostcard(
            final String pscId) throws ApiException, IOException {
        HttpRequest request = buildDeletePostcardRequest(pscId);
        authManagers.get("global").apply(request);

        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        return handleDeletePostcardResponse(context);
    }

    /**
     * Completely removes a postcard from production. This can only be done if the postcard has a
     * `send_date` and the `send_date` has not yet passed. If the postcard is successfully canceled,
     * you will not be charged for it. Read more on [cancellation
     * windows](#section/Cancellation-Windows) and [scheduling](#section/Scheduled-Mailings).
     * Scheduling and cancellation is a premium feature. Upgrade to the appropriate [Print & Mail
     * Edition](https://dashboard.lob.com/#/settings/editions) to gain access.
     * @param  pscId  Required parameter: id of the postcard
     * @return    Returns the PostcardDeletion response from the API call
     */
    public CompletableFuture<PostcardDeletion> deletePostcardAsync(
            final String pscId) {
        return makeHttpCallAsync(() -> buildDeletePostcardRequest(pscId),
            req -> authManagers.get("global").applyAsync(req)
                .thenCompose(request -> getClientInstance()
                        .executeAsync(request, false)),
            context -> handleDeletePostcardResponse(context));
    }

    /**
     * Builds the HttpRequest object for deletePostcard.
     */
    private HttpRequest buildDeletePostcardRequest(
            final String pscId) {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/postcards/{psc_id}");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("psc_id",
                new SimpleEntry<Object, Boolean>(pscId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().delete(queryBuilder, headers, null, null);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for deletePostcard.
     * @return An object of type PostcardDeletion
     */
    private PostcardDeletion handleDeletePostcardResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorErrorException("Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse) response).getBody();
        PostcardDeletion result = ApiHelper.deserialize(responseBody,
                PostcardDeletion.class);

        return result;
    }

    /**
     * Returns a list of your postcards. The addresses are returned sorted by creation date, with
     * the most recently created addresses appearing first.
     * @param  limit  Optional parameter: How many results to return.
     * @param  beforeOrAfter  Optional parameter: before and after are both optional but only one of
     *         them can be in the query at a time.
     * @param  include  Optional parameter: Request that the response include the total count by
     *         specifying `include[]=total_count`.
     * @param  dateCreated  Optional parameter: Filter by ISO-8601 date or datetime, e.g. `{ gt:
     *         '2012-01-01', lt: '2012-01-31T12:34:56Z' }` where `gt` is &gt;, `lt` is &lt;, `gte` is ≥,
     *         and `lte` is ≤.
     * @param  metadata  Optional parameter: Filter by metadata key-value pair, e.g.
     *         `metadata[customer_id]=987654`.
     * @param  size  Optional parameter: Specifies the size of the postcard. Only `4x6` postcards
     *         can be sent to international destinations.
     * @param  scheduled  Optional parameter: * `true` - only return orders (past or future) where
     *         `send_date` is greater than `date_created` * `false` - only return orders where
     *         `send_date` is equal to `date_created`
     * @param  sendDate  Optional parameter: Filter by ISO-8601 date or datetime, e.g. `{ gt:
     *         '2012-01-01', lt: '2012-01-31T12:34:56Z' }` where `gt` is &gt;, `lt` is &lt;, `gte` is ≥,
     *         and `lte` is ≤.
     * @param  mailType  Optional parameter: A string designating the mail postage type: *
     *         `usps_first_class` - (default) * `usps_standard` - a [cheaper
     *         option](https://lob.com/pricing/print-mail#compare) which is less predictable and
     *         takes longer to deliver. `usps_standard` cannot be used with `4x6` postcards or for
     *         any postcards sent outside of the United States.
     * @param  sortBy  Optional parameter: Sorts postcards by ascending or descending dates.
     * @return    Returns the AllPostcards response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public AllPostcards listPostcards(
            final Integer limit,
            final Object beforeOrAfter,
            final Object include,
            final LocalDateTime dateCreated,
            final Integer metadata,
            final PostcardSizeEnum size,
            final Boolean scheduled,
            final Object sendDate,
            final MailTypeEnum mailType,
            final Object sortBy) throws ApiException, IOException {
        HttpRequest request = buildListPostcardsRequest(limit, beforeOrAfter, include, dateCreated,
                metadata, size, scheduled, sendDate, mailType, sortBy);
        authManagers.get("global").apply(request);

        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        return handleListPostcardsResponse(context);
    }

    /**
     * Returns a list of your postcards. The addresses are returned sorted by creation date, with
     * the most recently created addresses appearing first.
     * @param  limit  Optional parameter: How many results to return.
     * @param  beforeOrAfter  Optional parameter: before and after are both optional but only one of
     *         them can be in the query at a time.
     * @param  include  Optional parameter: Request that the response include the total count by
     *         specifying `include[]=total_count`.
     * @param  dateCreated  Optional parameter: Filter by ISO-8601 date or datetime, e.g. `{ gt:
     *         '2012-01-01', lt: '2012-01-31T12:34:56Z' }` where `gt` is &gt;, `lt` is &lt;, `gte` is ≥,
     *         and `lte` is ≤.
     * @param  metadata  Optional parameter: Filter by metadata key-value pair, e.g.
     *         `metadata[customer_id]=987654`.
     * @param  size  Optional parameter: Specifies the size of the postcard. Only `4x6` postcards
     *         can be sent to international destinations.
     * @param  scheduled  Optional parameter: * `true` - only return orders (past or future) where
     *         `send_date` is greater than `date_created` * `false` - only return orders where
     *         `send_date` is equal to `date_created`
     * @param  sendDate  Optional parameter: Filter by ISO-8601 date or datetime, e.g. `{ gt:
     *         '2012-01-01', lt: '2012-01-31T12:34:56Z' }` where `gt` is &gt;, `lt` is &lt;, `gte` is ≥,
     *         and `lte` is ≤.
     * @param  mailType  Optional parameter: A string designating the mail postage type: *
     *         `usps_first_class` - (default) * `usps_standard` - a [cheaper
     *         option](https://lob.com/pricing/print-mail#compare) which is less predictable and
     *         takes longer to deliver. `usps_standard` cannot be used with `4x6` postcards or for
     *         any postcards sent outside of the United States.
     * @param  sortBy  Optional parameter: Sorts postcards by ascending or descending dates.
     * @return    Returns the AllPostcards response from the API call
     */
    public CompletableFuture<AllPostcards> listPostcardsAsync(
            final Integer limit,
            final Object beforeOrAfter,
            final Object include,
            final LocalDateTime dateCreated,
            final Integer metadata,
            final PostcardSizeEnum size,
            final Boolean scheduled,
            final Object sendDate,
            final MailTypeEnum mailType,
            final Object sortBy) {
        return makeHttpCallAsync(() -> buildListPostcardsRequest(limit, beforeOrAfter, include,
                dateCreated, metadata, size, scheduled, sendDate, mailType, sortBy),
            req -> authManagers.get("global").applyAsync(req)
                .thenCompose(request -> getClientInstance()
                        .executeAsync(request, false)),
            context -> handleListPostcardsResponse(context));
    }

    /**
     * Builds the HttpRequest object for listPostcards.
     */
    private HttpRequest buildListPostcardsRequest(
            final Integer limit,
            final Object beforeOrAfter,
            final Object include,
            final LocalDateTime dateCreated,
            final Integer metadata,
            final PostcardSizeEnum size,
            final Boolean scheduled,
            final Object sendDate,
            final MailTypeEnum mailType,
            final Object sortBy) {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/postcards");

        //load all query parameters
        Map<String, Object> queryParameters = new HashMap<>();
        queryParameters.put("limit",
                (limit != null) ? limit : 10);
        queryParameters.put("before-or-after", beforeOrAfter);
        queryParameters.put("include", include);
        queryParameters.put("date_created", DateTimeHelper.toRfc8601DateTime(dateCreated));
        queryParameters.put("metadata",
                (metadata != null) ? metadata : 0);
        queryParameters.put("size",
                (size != null) ? size.value() : "4x6");
        queryParameters.put("scheduled", scheduled);
        queryParameters.put("send_date", sendDate);
        queryParameters.put("mail_type",
                (mailType != null) ? mailType.value() : "usps_first_class");
        queryParameters.put("sort_by", sortBy);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().get(queryBuilder, headers, queryParameters,
                null);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for listPostcards.
     * @return An object of type AllPostcards
     */
    private AllPostcards handleListPostcardsResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorErrorException("Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse) response).getBody();
        AllPostcards result = ApiHelper.deserialize(responseBody,
                AllPostcards.class);

        return result;
    }

    /**
     * Creates a new postcard given information.
     * @param  body  Required parameter: Example:
     * @param  idempotencyKeyHeader  Optional parameter: A string of no longer than 256 characters
     *         that uniquely identifies this resource. For more help integrating idempotency keys,
     *         refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @param  idempotencyKeyParam  Optional parameter: A string of no longer than 256 characters
     *         that uniquely identifies this resource. For more help integrating idempotency keys,
     *         refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @return    Returns the Postcard response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Postcard createPostcard(
            final PostcardEditable body,
            final String idempotencyKeyHeader,
            final String idempotencyKeyParam) throws ApiException, IOException {
        HttpRequest request = buildCreatePostcardRequest(body, idempotencyKeyHeader,
                idempotencyKeyParam);
        authManagers.get("global").apply(request);

        HttpResponse response = getClientInstance().execute(request, false);
        HttpContext context = new HttpContext(request, response);

        return handleCreatePostcardResponse(context);
    }

    /**
     * Creates a new postcard given information.
     * @param  body  Required parameter: Example:
     * @param  idempotencyKeyHeader  Optional parameter: A string of no longer than 256 characters
     *         that uniquely identifies this resource. For more help integrating idempotency keys,
     *         refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @param  idempotencyKeyParam  Optional parameter: A string of no longer than 256 characters
     *         that uniquely identifies this resource. For more help integrating idempotency keys,
     *         refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @return    Returns the Postcard response from the API call
     */
    public CompletableFuture<Postcard> createPostcardAsync(
            final PostcardEditable body,
            final String idempotencyKeyHeader,
            final String idempotencyKeyParam) {
        return makeHttpCallAsync(() -> buildCreatePostcardRequest(body, idempotencyKeyHeader,
                idempotencyKeyParam),
            req -> authManagers.get("global").applyAsync(req)
                .thenCompose(request -> getClientInstance()
                        .executeAsync(request, false)),
            context -> handleCreatePostcardResponse(context));
    }

    /**
     * Builds the HttpRequest object for createPostcard.
     */
    private HttpRequest buildCreatePostcardRequest(
            final PostcardEditable body,
            final String idempotencyKeyHeader,
            final String idempotencyKeyParam) throws JsonProcessingException {
        //the base uri for api requests
        String baseUri = config.getBaseUri();

        //prepare query string for API call
        final StringBuilder queryBuilder = new StringBuilder(baseUri
                + "/postcards");

        //load all query parameters
        Map<String, Object> queryParameters = new HashMap<>();
        queryParameters.put("idempotency_key_param", idempotencyKeyParam);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("Idempotency-Key-Header", idempotencyKeyHeader);
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");
        headers.add("content-type", "application/json");

        //prepare and invoke the API call request to fetch the response
        String bodyJson = ApiHelper.serialize(body);
        HttpRequest request = getClientInstance().postBody(queryBuilder, headers, queryParameters,
                bodyJson);

        // Invoke the callback before request if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onBeforeRequest(request);
        }

        return request;
    }

    /**
     * Processes the response for createPostcard.
     * @return An object of type Postcard
     */
    private Postcard handleCreatePostcardResponse(
            HttpContext context) throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallback() != null) {
            getHttpCallback().onAfterResponse(context);
        }

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorErrorException("Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse) response).getBody();
        Postcard result = ApiHelper.deserialize(responseBody,
                Postcard.class);

        return result;
    }

}